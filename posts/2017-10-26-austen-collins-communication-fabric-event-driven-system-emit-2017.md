---
title: Austen Collins - Building the communication fabric for an event-driven system
description: We're posting the videos from Emit 2017! Here's Serverless CEO Austen Collins on the Event Gateway - a communication fabric for event-driven systems.
date: 2017-10-26
layout: Post
thumbnail: 'http://www.emitconference.com/assets/images/speaker-austen-collins.jpg'
authors:
  - AndreaPasswater
---

Austen Collins launched the latest project from [Serverless.com](https://www.serverless.com), the [Event Gateway](https://www.serverless.com/event-gateway). The Event Gateway facilitates cross-cloud serverless architectures: react to any event, with any cloud, on any provider.

Definitely watch the video; there's a sweet demo in there.

<iframe width="560" height="315" src="https://www.youtube.com/embed/wTEADkvUz14" frameborder="0" allowfullscreen></iframe>

# Transcript

**Austen:** I'm going to try and...tread into treacherous territory and do a demo of this talk. So I think we need just a second to get set up here with the AV team. 

Again, I'm [Austen Collins](https://twitter.com/austencollins). I'm a software engineer and the founder of a company called [Serverless Inc](http://www.serverless.com). At Serverless Inc., we make developer tools for developers and organizations that wanna build a managed serverless architectures. We're basically a group of people obsessed with developer productivity and experience. And if moving fast, we're using time to market, minimizing overhead aerial priorities. There's really no better option out there than to go with a serverless architecture right now. And we wanna help enable everyone to use this. So, if that's of interest to you, check it out. 

Our journey began in 2014 when AWS Lambda was first announced. And at the time, we saw this, and we had a theory. And that theory was that this new type of computing service in the Cloud, this innovation, that had the following qualities; auto-scaling, zero administration, function-based, pay-per-execution, event-driven compute. That these qualities would liberate a lot of developer productivity that was...and engineering productivity that was previously allocated to managing and maintaining infrastructure that they were using to run their apps. 

Further on this theory suggested that when you have these qualities; auto-scaling, zero administration, pay-per-execution, event-driven compute, that you've flattened the barriers, big barriers between developers and being able to provision a ton of logic. Producing results, shipping new features, new products, building business value all-day long. And, quite possibly, with this new compute service, we could end up in this new era of unprecedented productivity and automation, an event-driven automation. And all because Compute became so darn convenient. 

So in 2015, we tried to test out this theory. We wanted to take this compute service and build out an entire application on it. And of course, you know, we were excited about this, but we ran into this problem. And that is that this compute service requires doing things a little bit differently. And we didn't quite know what the architecture was at the end of the day, what this thing was ultimately gonna look like, you know. A.K.A. what is a serverless architecture? 

Most have settled on this answer. And, lots of components, you know. It's a database storage services, all managed ones if you're a serverless purist, communication infrastructure, API Gateways, SNS, IRT platforms, all with Lambda acting as the glue that kind of binds these things together. It's flexible. There's a lot of options there. But there's not much order. A lot of tight couplings between things. And, you know, to write this code, deploy the resources, manage the lifecycle, manage permissions across all these is hard. And as it grows, the complexity grows as well, and it gets a lot harder. There's no mystery why. It's just kind of complicated. It's kind of like a spaghetti infrastructure scenario. 

But this was, and is still kind of known as the service architecture today. And that promise of productivity that we originally saw is still there. It's just...we just didn't feel it was super accessible. Again, we're very focused in our company on experience and productivity. So we felt there was room for improvement, and we felt there could be a better experience. So we created something called the Serverless Framework. It's an application framework to help you build entire apps exclusively on AWS Lambda, and now, lots of other serverless compute providers like Azure Functions, Google Cloud Functions, IBM OpenWhisk. Some of the information on [inaudible 00:04:13] like Cubeless, we have Support Fuzz, which is built on top of Dr. Swam and integrations with other vendors as well. 

So you could use this to create data processing pipelines, backends, web mobile IRT, all types of event-driven automation. And the goal of the framework was to offer an abstraction over the complexity you saw in the previous slide. And to try also to define a new application experience for serverless architectures, that could realize that potential, that productive capacity that we saw when Compute Service was first announced. And to do this, the framework hides a ton of complexity and exposes just the bare minimum of information developers need to kind of get started. And the focus is on telling a simple story. And that story is a story of functions and events. 

So this is our configuration file with the framework. You know, one of the most important things here is just the functions property, which just gives a list of a whole bunch of different functions to do with various things. And each function has an events property where you could list all the events that trigger that function. And developers can use these two basic concepts to build large applications. Meanwhile, the framework in the background will go ahead and provision all the infrastructure, all the resource requirements needed to set this stuff up and wire it all together for you. But developers, again, just largely focus on this experience.

So this was our experiment. And this is what we presented to the world. And that experience took off like wildfire. First, the hobbyists came, soon after start-ups came, soon after that a large enterprise organizations came to use this. And all of a sudden, it's just like early...end of 2015, early 2016, a lot of case studies started popping up talking about all the great successes they've achieved with this framework, doing all types of things. Again, lots of data processing pipelines, backends, very cool event-driven automation, stuff we never even thought would be possible. 

Now this project is a very successful open-source project. We just broke through 18,000 GitHub stars. It has an incredibly active community. To give you some signal on that, I think about 60%, and we've been measuring this with GitHub stats, 60% of all the contributions are made from volunteers. So, outside contributors. And I think this project helped us get close to that original goal of realizing the potential of serverless compute and the productivity it promised. In addition, as we put it out, this project out there, we learned a lot of stuff that we didn't initially anticipate. 

Number one, convenience attracts all users and use-cases. This architecture is not meant for everything, of course. But you try telling that to these people. Because these qualities, you know; zero administration, event-driven, auto-scaling, pay-per-execution; these qualities are addictive. And people are just clambering over each other to take advantage of them. And they're fitting in a lot of stuff in this architecture it's not perfect for. But they're doing it, and they like it. And even if they have to implement some type of somewhat hacky-work-around, a lot of them still turn around, and they tell us, "We still feel like we ended up with a net gain here, and we don't have to go hire more engineers at the end of the day too, so." Anyway, that was the first interesting thing that we saw. 

Number two. All of a sudden 2016, we started to see this pattern, and that is serverless teams being and spawning in enterprise organizations starting with some progressive engineer who took the knowledge of Lambda and the service framework into their organization, and they started looking around thinking, "Oh. What jobs can I put into a Lambda function? How..." you know, "What can I...how can I reduce my overhead?" A lot of these engineers would start kind of automating just DevOps tasks as a common starting point. And they would do these experiments, and they'd work. And they're other teams, other people would take notice, their organizations would take notice, and soon that scrappy kind of visionary in the enterprise org is joined by a couple other engineers. And this was, you know, the birth of the serverless team. 

These serverless teams are incredibly productive. You know, Lambda, Azure Functions, Google Cloud Functions, these are micro-service, managed micro-service services essentially. And they reduce that overhead that you get with the traditional micro-service architecture. And because of that, we see people provisioning I'd say around 10x more functions than micro-services. These teams, these serverless teams, have one or two scrappy engineers that are putting together hundreds of functions into your production, doing billions of invocations. And, a lot of them are forgetting all the stuff that they deployed, or at least, they can't even remember where they stuck these functions and where they're located. 

So it's an awesome problem to have, because again we start seeing that original promise being realized. After serverless teams started gaining ground and gaining more recognition in the organization, we sat down with managers and business leadership, and we started hearing this at the end of 2016 and early 2017. They said, "Serverless first. Our biggest problem is just getting stuff out there to the market as fast as possible that has the lowest total cost of ownership, minimal overhead." And they said, "Look, we understand it's not meant for everything, but we wanna do as much as we can in a serverless architecture first. And only when we can't surpass these limitations, do we fall back on traditional technology." So, this was...this is pretty interesting to hear. Big organizations are telling us this. 

Another big learning is that some people don't call it "serverless," they call it "service-full." You know, half the value of serverless compute is all...is having an eco-system of other services, you know, preferably managed services that that compute can work with. It's hard to just put the compute out there by itself if there's not really a lot of great things you could really do with it. So, you know, when we see a serverless architecture, and like we saw in the earlier slide, they're, you know, these architectures are just comprised of all types of other services. So some people call it "service-full." 

And, this trend kinda grew into another trend, which is, a lot of people started thinking about this architecture as a way to do a multi-Cloud strategy. So new service compute options emerged after Lambda, Azure Functions, Google Cloud Functions, IBM OpenWhisk, tons of great options. And our users wanted to use them. And they didn't just want to use those compute services; they wanted to use all the other great services that those cloud providers offer. 

So, a common example we hear is, "How...we've built a serverless architecture. It's on Amazon. We're using...We got a lot of Lambda functions; it's going great. But we really wanna use Google's machine learning stuff. Like, is there any way that we could just take a function and stick it...a Google Cloud function, put it into Google Cloud, and start working with machine learning over there and, kind of have that function be treated though, as a piece of our kind of integrated kind of multi-Cloud serverless architecture?" 

So that was interesting behavior. And we hear this more and more. I think these Functions-as-a-Service serverless compute are the easiest, low-friction way to adopt a Cloud provider and gain access to all the valuable services that these providers are producing at an incredible rate. You wanna use some fancy managed service on a big provider? Stick a function there. And from within that code, you could do all types of things. 

So the Serverless Framework, when we saw this behavior, we pivoted early 2016. We said, "Look, this is what people are asking us for. We want to enable this, we're here to enable developer productivity and experience," and if you're a developer, you're an organization and you wanna solve a business problem, you wanna take advantage of any service out there that helps you solve the problem best and fast, regardless of the cloud platform that it's on. So we wanted to encourage this pattern, and we pivoted a framework so that it offered one uniform experience so you could write everything one way and deploy it to multiple providers. 

As of today, I think we have nine different integrations for places you could deploy serverless compute to. And it's going really well. The community is enjoying it a lot. You know, it's interesting to see this pattern. It's like, when Amazon Lambda was introduced, I think Amazon thought of it as the glue to make AWS services kind of glued together, to get those binded together. But I think what we're seeing is that the serverless function concept, in general, is becoming the glue for all internet services. So, we wanna help enable that. 

And lastly, you know, another big learning was that this application experience resonated with people. This story of functions and events. And it seems very much like this is becoming the new Pass. Sometimes we describe serverless as just "Pass 2.0," it just has different abstractions. And people are trying to build serverless platforms, I think, that are largely modeled after this experience. A lot of people want their own kind of on-print serverless platform, and we see them recreating just versions of this. 

And it's super accessible, this whole model, I think for, you know, new developers to long-time enterprise engineers who haven't even done any cloud work yet. Some signal on this is that we surveyed our community, the Serverless Framework community, and 25% of our users had never used a major cloud provider before. But this pattern does such a great job of keeping...of simplifying the Cloud and kind of surfacing what matters that, a lot of people are using the framework as an entry point to start adopting Cloud providers. 

Meanwhile, larger organizations who are just adopting Cloud, or they want to or have plans to in the future, they say, they're telling us that they wanna go straight to a serverless architecture because it's simple and the only things that really matter are kind of surfaced immediately, and they need to retrain this entire workforce that they have, that has no knowledge of Cloud, to start doing Cloud stuff. And this seems like the easiest way for them to do it. So this application experience, largely, has been a huge success. And again all these learnings we could see. All these were just evidence that that potential, that productive capacity is there. And if you could wrap these stuff in a great experience, make it more accessible to people, more people could take advantage of it. It's, you know, more democratized. 

At the same time, we learned something that was also tough to hear. And that it's still hard to do a big project with serverless architecture. So, as you saw in the diagrams before, the architecture gets very complex. You know, we talked to a lot of our users all the time. We could see what their issues are. A lot of these issues could just be jumbled under this single category, which is architectural complexity. And after the framework came around, there was also...another symptom of this was just all the other tools had emerged to help people handle and tame this architecture; lots of dev tools, testing tools, infrastructures' code tools. But there's only so much a tool can do at the end of the day. 

So back at Serverless Inc., we put our heads together and started discussing additional solutions. We decided, this time, to strike at the heart of the problem and see if there was a new piece of infrastructure that could reduce complexity and bring order to the serverless architecture while enabling productivity, of course, and also incorporating some of the new learnings that we had. And because this architecture is inherently event-driven, we felt this new piece of infrastructure should be purely event-driven as well. 

So we have a new open-source project. It's available today in our GitHub organization. It's called the "[Event Gateway](https://serverless.com/event-gateway/)." We call it the highly productive event router for Functions-as-a-service. And productivity being the highlight here. Again, that's like the big goal that we're optimizing for. And, you know, serverless computing offers that. The potential is there. We think this piece of infrastructure is gonna greatly help people realize that potential. 

So this thing has a few simple goals. Number one, express all data as events. You send data into it; it's always gonna interpret it as events. This thing has a one-track mind. It sees the world as events.

Number two, react to any event with any Functions-as-a-Service in any location. Right. This is what people have asked us for. They view Functions-as-a-Service as the front doors to cloud providers, and we want to enable this.

Number three, be flexible. Accommodate many use-cases. This isn't your typical event-router, or event-broker, or kind of Pub/Sub system. This is also a higher-level abstraction that seeks to accommodate many of the use-cases that we see people building with serverless architectures. And it's mostly APIs, backends, that's also Pub/Sub systems and event-driven workflows. This is not gonna be a new piece of infrastructure that you add. It's seeking to replace multiple pieces of infrastructure that you have to reduce that complexity and reduce that overhead. 

Last goal. Decouple logic. Decouple teams. And that's a big important goal if you want to increase productivity not just for the developers, but for their teams and for their entire organizations. 

So, express all data as events. This thing receives data via HTTP, interprets it as an event. It ingests custom event schemas. However, even when an HTTP request comes in, and it doesn't contain any event information, the Event Gateway declares the whole HTTP request in HTTP event. And this helps us accommodate the API Gateway use-case. We'll talk about that in just a second. Also, any Logs, Metrics, Errors that happen in the Event Gateway are all emitted as events, which again, you can react to with functions anywhere. 

There is no storage in this thing. This thing is simple priority right now. Its early project is just to get data over to express as events and route it over to serverless functions everywhere. In the future, we have plans to add middle-wares for storage, but everything is in events. And again, this thing has a one-track mind. I personally believe that great design is grounded in the theme, and events are the theme of this. And the gateways stick to it. And the bonus is, of course, when you combine this philosophy with serverless computing, the result is awesome productivity. 

So, react to any event with FaaS in any location. So, again it works with all types of events you could send into it, supports the major serverless compute providers already, and this is gonna be all-in-one solution for function discovery, composition, and communication. Be flexible. Accommodate many use-cases. 

So, this thing is largely a Pub/Sub system. You can send in HTTP request, send your HTTP request with special headers and the Event Gateway will look at that, and it'll extract the body of that HTTP request if it has the headers, and declare that as the event. But again, to accommodate API Gateway use-cases, if an HTTP request comes in without the special headers, then the HTTP requests themselves are treated as an HTTP event. 

Also, Webhooks. This thing is going to have a built-in intelligence of Webhooks structures from popular SaaS providers; Salesforce, GitHub, Stripe, so that it can immediately integrate with those providers and convert those to events as well. And this is all gonna create a great experience with our serverless framework, which I'll show off in just a bit. I mean finally, for the first time, you're gonna be able to put not just provider-specific events in your service configuration file, you can put all types of custom events and SaaS events as well. 

So regardless of how you use it, this is all happening underneath the hood. HTTP request comes in, with or without special headers, it's identified as an event. Any subscriptions for that event, any bindings between the events and Functions-as-a-Service are fetched. Event data is filtering. So this thing is going to do some basic filtering. And then, the subscriptions are processed, and the data is dispatched to Functions-as-a-Service. 

Now, this thing can do synchronous calls to help accommodate the API Gateway use-case. And it could also do asynchronous calls as well, or both at the same time. A cool example of this is when an HTTP request is converted to an event. You could have a function that's listening for that event, and it could respond to it to create this traditional request-response flow. But you could also have function sitting...subscribed to this to fire asynchronously off the event. So you can monitor all traffic, incoming and outgoing because all these stuff is being treated as an event. So you could check out how much traffic you're receiving, you can monitor status codes, all types of stuff like that. You don't get this with your traditional API Gateway. And it's one of the first benefits of just building this entire thing on a singular event-driven experience.

Decouple logic, decouple teams. So, Functions-as-a-Service does a great job of decoupling logic, right? You get all these independent units of deployment. Developers and teams can own their own functions, and they could deploy these, they could upgrade them, they could roll them back, without affecting the system as a whole. That's fantastic. 

However, in serverless architectures, we see that these functions are usually binded to some other piece of infrastructure that's shared. And this creates like a blocking pattern for these teams, and they can't quite realize this autonomy that Functions-as-a-Service promised. A good example of this is API Gateway, right? You could be a developer owning some functions that are hooked up to a broader REST API for your company, but you can't really push that stuff into production easily without interacting with whoever owns that REST API. So we wanted to change that. 

And the great thing is about event-driven design is that it decouples teams very well. There's no notion of this huge REST API which everyone has to share, there's just events here. And all the participants in this event-driven interaction are self-contained, independent actors. So your developers can own some kind of core app logic functions, marketers can be responding to events being emitted into the Event Gateway maybe for user activity, marketers can own their own functions that they're using to send emails out to users or create personalized experiences. Operators can also have their own functions. Again, this thing expresses all logs, warnings, everything as events. So operators can start automating any potential issues with their own sets of functions. 

And this is great. I think this is really gonna accelerate the productivity of the serverless architecture and productivity of the serverless team in general. The only thing that you have to respect, of course, is the event schema, which is the contract here.

So this is, you know...where we are right now, somewhat simplified. You have usually some type of workflow system like Step Functions and Streaming Data system, Pub/Sub infrastructure, API Gateway infrastructure. Where we'd like to go with this is just to simplify it with the right abstraction. And, of course, getting that abstraction right is tricky. But we think that there's opportunity here to do so. Just kind of like what Functions-as-a-Service are at the end of the day. Just a beautiful abstraction. So yeah, we wanna unify a lot of those mediation tools you saw in the previous slide into this abstraction. 

And these features make up the Event Gateway. Use it for a few tasks for your application, or you could use this to power your entire digital business. It's Open Source. You can install it on PRIM in the Cloud. It's written in Go. There is a great roadmap on the Open Source project. We think it's a missing fundamental component of the serverless architecture and any serverless platform you seek to build.

So now this is a piece of infrastructure. It's an early version; it's not ready for production. We're just putting it out early there for feedback. And, however, you could actually use it right now because we wanted people to get their hands on it to kind of realize the power of this thing. And because it's Open Source, they could easily download it, and it runs locally on your machine. And the first thing we prioritized was just a great local experience with the serverless framework. And we'll demonstrate that now if the demo-gods are feeling good about me at the moment so that you could see the magic of this infrastructure. 

So, first off, we have an example project here. Okay, example project here. So this is a basic serverless architecture. It's somewhat simple. There is a frontend, of course. It's a basic web application that's built in React and Redux. And in the backend, it's entirely serverless. And that is that it's comprised of nothing but functions. And you could see all the functions here organized into different serverless framework projects, what we call, "services." Each one of these folders contains one, or multiple functions focused on some specific domain. 

So I'm gonna boot up the front-end here. Then you could see it on the left. It's a basic web application. Again, this thing doesn't do much. It's just a cool learning page that advertises why serverless architectures are awesome. There's some marketing copy down here. It doesn't really do anything. The only thing this actually does is saves the user to a database and logs them into a session. 

Now, the cool thing about this is that this entire application is powered by the Event Gateway. It features REST API, Pub/Sub systems, and a lot more which I'll show off in a second, all using Event Gateway. And the serverless framework now features a new command that was bundled in the release that we just pushed out today, called "Serverless Run."

So, in this project here, I'm gonna go into the services that we saw, and I'm gonna start off with a blank service. So this service doesn't have any functions in it. And the reason why I'm gonna start off with this is because I just wanna show off how this thing treats, handles HTTP requests as events. 

So, Serverless Run just created a working session. It initialized a brand new emulator that emulates Lambda Functions, Google Cloud Functions and more locally with great accuracy. It also brought down the Event Gateway. It just pulled the most recent release, installed it on my machine, and spun it out. 

So, we have two different voices here. We have the serverless framework, which is in charge of kind of emulating your functions locally, and we have the Event Gateway, which is in charge of just routing events over to these locally emulated functions. So everything is initialized here in this application. When I hit this "Register" button it's just gonna send HTTP request with a post method over to the Event Gateway. And I'll do that right now.

So you can see the Event Gateway just reported, "HTTP event received." And again, it's not just some unusual form of data. This is an event object. So we have a simple event envelope that we put on here, and all the information about, from the HTTP request, is put into this request body. So you could see headers, of course, query, parameters, the body, here's my email address that I put in there, path method, all that good stuff. I could hit this a whole bunch of times and just hammer the Event Gateway with requests and, you know, you'll see the HTTP events coming into this thing. Then you could view it all right here in this easy session.

Now I'm gonna clear it. And this is one of the things I really love about this experience. So now I wanna bring in some functions to subscribe to these events. And the way you do that is, you go into a separate tab here, and I can go into my services. I'm gonna list...I'm gonna go into my users-functions, and I'm gonna run Serverless Run in here again. And the framework is already gonna detect that there's a session running right now. And it's just going to add in all the functions from the project that I just [inaudible 00:28:23] into my current session. 

So if I go back into my original tab, you could see it's reporting, "Users register functions was loaded." And the Event Gateway says, "Oh. We just registered that in the Event Gateway and created a subscription for the user's register function on the HTTP event." And if you look at the serverless framework configuration file here, you could see where this is defined. Pretty simple stuff. Here is the users register function and the event is HTTP. 

Now, this function is just gonna save the user to a database. And additionally, after it saves the user to a database, it's gonna use the Event Gateways SDK to emit a user-registered event with some information about that user. 

So let's run it through it right now. So, I'm gonna hit "Register" one more time. And you could see the HTTP event came in. Again, it has my email address right there. And then the serverless framework responded and said, "Oh. The users register function was just triggered by the HTTP event." That function ran successfully and emitted the user-registered events to the Event Gateway. The Event Gateway said, "Hey, we just received this event," and then serverless responded saying, "Users register function has finished."

So, pretty basic stuff here. And you could see the beginning of a workflow. Also, going back to our goals. One of those goals was, be flexible, you know, accommodate a lot of use-cases. Already with this one piece of infrastructure, we've built a basic API, backend, as well as Pub/Sub functionality happening here. So let's do more with this. 

So we've got more functions to work with. And I'm gonna bring in some email functions here. Actually, just one of them. So, this is an email service. It has one function, which sends a welcome email. And I'm gonna load that into my working session here. And so you can see, serverless framework has received this welcome email that's been registered in the Event Gateway and a subscription was created for the event user-registered and the function, "Send welcome email." So if I look at that configuration file for this one, you could see, "Send welcome email," the function is listed here and the event is user.registered. Pretty simple stuff.

And the code in here is just going to send out a transactional email, or send out a welcome email. After that's done, it's going to also emit another event, which is, "Email sent." So I run through the workflow real quick. And again, HTTP request came in, and it triggered the users-register function that emitted a user-registered event, which then triggered the "Send welcome email" function, triggered by the user-registered event here. The user-registered event finished, and the "Email sent" event was emitted because that "Send welcome email" function sent out the welcome email, and then that function finished. So, pretty easy stuff. 

And you could see a larger workflow is being added on here. And this kinda touches on another one of our goals which was, "Decouple logic, decouple teams." The great thing about this is, you know, the developers could be working on those user Cloud operations, and whoever owns, maybe the marketing teams or stuff like that, whoever is in charge of doing...handling user activity and sending out emails and stuff; they could have their own functions that they're working on that just interact with this users-registered event, you know. They don't need to be tied to some big API Gateway or share some other big infrastructure dependency. Oh, also, by the way, you can see that we've logged in here and created a simple session. 

Okay. So let's add one level of complexity here. We have an Analytics Function we wanna bring in. And you could see that being reported here. Now, this function...all these other functions are AWS Lambda functions. That's where our...that's what's being emulated locally. Now, this function though is an Analytics Function that saves all user activity to BigQuery, and what we're emulating here is actually a Google Cloud Function. And so you can see this kinda touches on our second goal, which is, be able to react to any event with any Functions-as-a-Service here. So now we're kind of like piecing together this multi-Cloud architecture locally.

So I'm gonna run through the flow again. Everything happened as usual. HTTP event came in; users register function was triggered. That emitted an event which sent the "Welcome" email". But this Analytics Function was also triggered by the users-registered event. And this Analytics Function then went and inserted some of...that user-registered event into BigQuery. Pretty easy stuff.

You can start to see the multi-Cloud serverless architecture coming together here. And we're testing all these stuff out locally without having to provision anything. We haven't really deployed anything yet. 

Bonus. The SDK that comes with this is JavaScript right now, and it's built to be running node as well as the browser. And because this front-end application here, this web application was built with React and Redux, which is also a great event-driven framework, we were able to just slip the SDK for the Event Gateway right into Redux as a middleware so that it could just tap into whatever events that it thinks are interesting on the client side, and selectively send those to the Event Gateway as well. 

So one of the cool thing about this app is that whenever a user is logged into a session, this app will start tracking their activity. So if I hit a button here, you could see that the client side is actually sending events to the Event Gateway as well. And this Analytics Function is not only set to respond to user-registered events, but it's also set to respond to user-clicked events as well. 

So this analytics...so, we now have events coming from our REST API, we have events coming, just being sent around the Pub/Sub pattern, and now we have events coming from the browser. You could use this...marketing teams could be working on this to create personalized experiences, you know, show users recent activity, tracking all their analytics in the dashboard. You can even use this to track client-side errors as well. Send those apps and react to them with Functions-as-a-Service. Send those over to operators possibly. I mean, there's all types of SaaS that's dedicated to just doing these stuff. But again, we're accommodating all these with just one flexible event-driven experience and it's pretty cool. 

Okay. One last thing. That was also a pretty big workflow. You could see how it gets complex. There's two ways you can get around this. We also have some other tooling coming out which is gonna make observability, visualization a lot easier around all this stuff. But the great thing about this right now is that you could just bring in components selectively, the stuff that you wanna work with. You don't have to bring in everything. There's also an emit command that works in Serverless Run, so you can emit an event at any time to kick off, like in the middle of a workflow you just test out one function. 

Yes. We have plans to offer this as a hosted service, of course. But it's always gonna be Open Source as well so you could run it whenever you'd like to run it, in your Cloud provider of choice in whatever region. 

Yes. Yeah. Exactly. Or, you could run it on PRIM as well. 

Okay. So I'm clearing out my session here. I wanna show off just a couple more functions. So we're gonna go into our users and do...I'm gonna start this up again. [inaudible 00:36:30]. Users [inaudible 00:36:32] run. So we started up our users-functions to respond to HTTP events. 

Now, we're also gonna bring in another function that does CRM functionality. And this function is designed to react to a user-registered event and save the user information to Salesforce. And my favorite thing about this function, of course, is that it does not work. It is broken. So, the code is actually broken. It emits an error. So the great thing about the gateway of course though, is that it reports this stuff in the form of events. 

So let's see what happens when we try the workflow here. You could see in our session; the HTTP event came in, the registered function was triggered. The user-registered event was sent out, which triggered the "Add user to CRM" function. And this function failed due to an error, which is reported nicely here, in your session. 

At the same time, the Event Gateway reacted to this and responded with a function error. And the gateway will always do this whenever your function code is broken, or the Cloud provider is down, which as much as we hate to admit it, can happen. So...but the great thing is that you can program kind of reactive logic to help handle situations like these. 

So we do have a simple...we have some error functions here. Actually, just one. And I'll bring that into my session. And let's try going through the flow one more time. Everything happened again, as it did before. The function error was sent out there, and now a function reacted to that, which simply alerts the admin, whether it's sending an email to them, sending a slack message to them, taking that error and visualizing it in the dashboard. Heck, you could even put the Event Gateway SDK into a function and react to an error and then write some code to roll back that function or, set the Event Gateway up to listen to a function on a different region, or a different Cloud provider so that you could build systems that self-heal, essentially. And again, great part is, all this is emulated locally right here in the browser. I'm sorry, on your machine. 

Okay. But that's it. That's the Event Gateway. That's it. It's on early stage project. Jump on its Open Source. You could play with it right now. And we think it's that missing piece that hasn't existed before for the serverless architecture. We think it's that missing piece that's gonna touch on our original goal of enabling productivity, of enabling developers and offering this fantastic experience as well. 

So, please check it out. The GitHub repo is right here. Also wanna thank Maciej, our lead architect on this project. If you have a lot of hard questions, direct them his way. Here is his twitter handle. And again, we're Serverless Inc. We do this stuff all day long. So if you wanna talk about building great developer experiences for serverless architectures, event-driven architectures, we'd love to have that conversation anytime. 

So, thank you everyone.
